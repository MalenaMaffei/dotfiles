#!/usr/bin/env bash

set -e

wmTMP='/tmp/.wm'
wmWinBkp="${wmTMP}/.wbkps"
wmGrpLst="${wmTMP}/.grpls"
wmGrpBkp="${wmTMP}/.gbkps"
wmWinFS="${wmTMP}/.winfs"

[[ ! -d "${wmTMP}" ]] && mkdir -p "${wmTMP}"

PAD_TOP="${PAD_TOP:-0}"
PAD_BOT="${PAD_BOT:-0}"
PAD_LEFT="${PAD_LEFT:-0}"
PAD_RIGHT="${PAD_RIGHT:-0}"
WIN_BORDER="${WIN_BORDER:-0}"

# b(ac)k(u)p w(indow) <WID> [.. <WID>]
function bkpw(){
  for winID in "${@}"; do
    local winX=$(wattr x "${winID}")
    local winY=$(wattr y "${winID}")
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    [[ $(grep "${winID}" "${wmWinBkp}") ]] && continue

    echo "${winID};${winX};${winY};${winW};${winH}" | tee -a "${wmWinBkp}"
  done
}

# r(e)st(ore) w(indow) <WID> [.. <WID>]
function rstw(){
  for winID in "${@}"; do
    local winProp=$(grep "${winID}" "${wmWinBkp}")

    [[ "${winProp}" == '' ]] && continue

    local winX=$(echo "${winProp}" | cut -d ';' -f 2)
    local winY=$(echo "${winProp}" | cut -d ';' -f 3)
    local winW=$(echo "${winProp}" | cut -d ';' -f 4)
    local winH=$(echo "${winProp}" | cut -d ';' -f 5)

    wtp "${winX}" "${winY}" "${winW}" "${winH}" "${winID}" # Teleport window
    mapw -m "${winID}" # Show window

    sed -i "/${winID}/d" "${wmWinBkp}"
  done
}

# foc(us) w(indow) l(eft)/r(ight)/u(p)/d(own)/p(rev)/n(ext)
function focw(){
  local winID=$(pfw)
  case $1 in
    l) wtf $(lsw | xargs wattr xi | sort -nr | sed "0,/$winID/d" | sed "1s/^[0-9]* //p;d");;
    r) wtf $(lsw | xargs wattr yi | sort -n | sed "0,/$winID/d" | sed "1s/^[0-9]* //p;d");;
    u) wtf $(lsw | xargs wattr yi | sort -nr | sed "0,/$winID/d" | sed "1s/^[0-9]* //p;d");;
    d) wtf $(lsw | xargs wattr xi | sort -n | sed "0,/$winID/d" | sed "1s/^[0-9]* //p;d");;
    n) wtf $(lsw | grep -v $winID | sed '1 p;d') ;;
    p) wtf $(lsw | grep -v $winID | sed '$ p;d') ;;
  esac
}

# mov(e) w(indow) l(eft)/r(ight)/u(p)/d(own) inc(+)/dec(-)/to(=) ?px/?% <WID> [.. <WID>]
function movw(){
  local moveDir=${1} # l|r|u|d
  local moveMod=${2} # +|-|=
  local moveVal=${3} # ?px|?%
  shift; shift; shift # clear above args
  local winIDs="${@}" # other args should be windows

  local rootWin=$(lsw -r)
  local rootW=$(wattr w "${rootWin}")
  local rootH=$(wattr h "${rootWin}")

  # if value is in percentage, calculate it now
  if [[ "${moveVal}" == *% ]]; then
    moveVal=$(echo "${moveVal}" | tr -d '%')
    if [[ "${moveDir}" == 'l' || "${moveDir}" == 'r' ]]; then
      moveVal=$(echo "scale=0; ${rootW}/100*${moveVal}" | bc -s)
    else
      moveVal=$(echo "scale=0; ${rootH}/100*${moveVal}" | bc -s)
    fi
  fi

  # if value has pixel suffix, remove it
  [[ "${moveVal}" == *px ]] && moveVal=$(echo "${moveVal}" | tr -d 'px')

  for winID in "${winIDs[@]}"; do
    local winX=$(wattr x "${winID}")
    local winY=$(wattr y "${winID}")
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    if [[ "${moveDir}" == 'l' && "${moveMod}" == '-' ]] || [[ "${moveDir}" == 'r' && "${moveMod}" == '+' ]]; then
      wmv "${moveVal}" 0 "${winID}"
    elif [[ "${moveDir}" == 'l' && "${moveMod}" == '+' ]] || [[ "${moveDir}" == 'r' && "${moveMod}" == '-' ]]; then
      wmv "$((0 - moveVal))" 0 "${winID}"
    elif [[ "${moveDir}" == 'l' && "${moveMod}" == '=' ]]; then
      wtp "${moveVal}" "${winY}" "${winW}" "${winH}" "${winID}"
    elif [[ "${moveDir}" == 'r' && "${moveMod}" == '=' ]]; then
      wtp "$((rootW - winW - moveVal))" "${winY}" "${winW}" "${winH}" "${winID}"
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '-' ]] || [[ "${moveDir}" == 'd' && "${moveMod}" == '+' ]]; then
      wmv 0 "${moveVal}" "${winID}"
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '+' ]] || [[ "${moveDir}" == 'd' && "${moveMod}" == '-' ]]; then
      wmv 0 "$((0 - moveVal))" "${winID}"
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '=' ]]; then
      wtp "${winX}" "${moveVal}" "${winW}" "${winH}" "${winID}"
    elif [[ "${moveDir}" == 'd' && "${moveMod}" == '=' ]]; then
      wtp "${winX}" "$((rootH - winH - moveVal))" "${winW}" "${winH}" "${winID}"
    fi
  done
}

# tel(eport) w(indow) <x> <y> <WID> [.. <WID>]
function telw(){
  local newX=${1}
  local newY=${2}
  shift; shift
  local winIDS="${@}"

  for winID in "${winIDs[@]}"; do
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    wtp "${winX}" "${winY}" "${winW}" "${winH}" "${winID}"
  done
}

# res(ize) w(indow) l(eft)/r(ight)/u(p)/d(own)/h(eight)/w(idth) inc(+)/dec(-)/to(=) ?px/?% <WID> [.. <WID>]
function resw(){
  local resDir=${1} # l|r|u|d
  local resMod=${2} # +|-|=
  local resVal=${3} # ?px|?%
  shift; shift; shift # clear above args
  local winIDs="${@}" # other args should be windows

  # if value is in percentage, calculate it now
  if [[ "${resVal}" == *% ]]; then
    resVal=$(echo "${resVal}" | tr -d '%')
    local rootWin=$(lsw -r)
    local rootW=$(wattr w "${rootWin}")
    local rootH=$(wattr h "${rootWin}")
    if [[ "${resDir}" == 'l' || "${resDir}" == 'r' || "${resDir}" == 'w' ]]; then
      resVal=$(echo "scale=0; ${rootW}/100*${resVal}" | bc -s)
    else
      resVal=$(echo "scale=0; ${rootH}/100*${resVal}" | bc -s)
    fi
  fi

  # if value has pixel suffix, reres it
  [[ "${resVal}" == *px ]] && resVal=$(echo "${resVal}" | tr -d 'px')

  for winID in "${winIDs[@]}"; do
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    if [[ "${resDir}" == 'l' && "${resMod}" == '+' ]] || [[ "${resDir}" == 'r' && "${resMod}" == '-' ]]; then
      winW=$((winW + resVal))
    elif [[ "${resDir}" == 'l' && "${resMod}" == '-' ]] || [[ "${resDir}" == 'r' && "${resMod}" == '+' ]]; then
      winW=$((winW - resVal))
    elif [[ "${resDir}" == 'w' && "${resMod}" == '=' ]]; then
      winW=$((resVal))
    elif [[ "${resDir}" == 'u' && "${resMod}" == '+' ]] || [[ "${resDir}" == 'd' && "${resMod}" == '-' ]]; then
      winH=$((winH + resVal))
    elif [[ "${resDir}" == 'u' && "${resMod}" == '-' ]] || [[ "${resDir}" == 'd' && "${resMod}" == '+' ]]; then
      winH=$((winH - resVal))
    elif [[ "${resDir}" == 'h' && "${resMod}" == '=' ]]; then
      winH=$((resVal))
    fi
    wrs -a "${winW}" "${winH}" "${winID}"
  done
}

# mod(ify) w(indow) h(ide)/(m)a(ximize)/d(efault) <WID> [.. <WID>]
function modw(){
  local winAct=${1}
  shift
  local winIDs="${@}"

  for winID in "${winIDs[@]}"; do
    case "${winAct}" in
      'h')
        bkpw "${winID}"
        mapw -u "${winID}"
      ;;
      'd')
        rstw "${winID}"
      ;;
      'm')
        if [[ -f "${wmWinFS}" ]]; then
          resw $(cat "${wmWinFS}")
          rm "${wmWinFS}"
        fi
        bkpw "${winID}"
        mapw -m "${winID}"
        wtp $(wattr xywh `lsw -r`) "${winID}"
      ;;
    esac
  done

  return
}

# mo(dify) w(indow) s(tacking order) inc(+)/dec(-)/to(=)/f(ront)/b(ack) ? <WID> [.. <WID>]
function mows(){
  return
}

# sna(p) w(indow) t(op)/b(ottom)/l(eft)/r(ight)/t(op)l(eft)/t(op)r(ight)/b(ottom)l(eft)/b(ottom)r(ight)/c(enter) <WID> [.. <WID>]
function snaw(){
  local winPos=${1}
  shift
  local winIDs="${@}"

  local rootWin=$(lsw -r)
  local rootW=$(wattr w "${rootWin}")
  local rootH=$(wattr h "${rootWin}")

  local rootW=$((rootW - PAD_LEFT - PAD_RIGHT))
  local rootH=$((rootH - PAD_TOP - PAD_BOT))

  for winID in "${winIDs[@]}"; do
    case "${winPos}" in
      't') wtp "${PAD_LEFT}" "${PAD_TOP}" "$((rootW - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
      'b') wtp "${PAD_LEFT}" "$((PAD_TOP+rootH/2))" "$((rootW - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
      'l') wtp "${PAD_LEFT}" "${PAD_TOP}" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH - (2 * WIN_BORDER)))" "${winID}";;
      'r') wtp "$((PAD_LEFT+rootW/2))" "${PAD_TOP}" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH - (2 * WIN_BORDER)))" "${winID}";;
      'tl') wtp "${PAD_LEFT}" "${PAD_TOP}" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
      'tr') wtp "$((PAD_LEFT+rootW/2))" "${PAD_TOP}" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
      'bl') wtp "${PAD_LEFT}" "$((PAD_TOP+rootH/2))" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
      'br') wtp "$((PAD_LEFT+rootW/2))" "$((PAD_TOP+rootH/2))" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
      'c') wtp "$((PAD_LEFT+rootW/4))" "$((PAD_TOP+rootH/4))" "$((rootW/2 - (2 * WIN_BORDER)))" "$((rootH/2 - (2 * WIN_BORDER)))" "${winID}";;
    esac
  done
}

# b(ac)k(u)p g(roup) <GID> [.. <GID>]
function bkpg(){
  return
}

# r(e)st(ore) g(roup) <GID> [.. <GID>]
function rstg(){
  return
}

# gro(up) w(indow) <GID> add(+)/del(-)/set(=) <WID> [.. <WID>]
function grow(){
  local grpID=${1}
  local grpAct=${2}
  shift; shift
  local winIDs="${@}"

  if [[ "${grpAct}" == '=' ]]; then
    sed -i "/^${grpID}/d" "${wmGrpLst}"
  fi

  if [[ ! $(grep "\^${grpID}" "${wmGrpLst}") ]]; then
    echo "${grpID};s;" >> "${wmGrpLst}"
  fi

  # Lines look like '0;s;0x00000010;0x00000019'
  local grpLine=$(grep -n "\^${grpID};" "${wmGrpLst}" | cut -d ';' -f 1)

  for winID in "${winIDs[@]}"; do
    case "${grpAct}" in
      '+'|'=') sed -i "${grpLine}s/$/${winID}\;/" "${wmGrpLst}";;
      '-') sed -i "${grpLine}s/${winID}\;/d" "${wmGrpLst}";;
    esac
  done
}

# mod(ify) g(roup) <GID> s(how)/h(ide)/t(oggle)/c(lear)
function modg(){
  local grpID=${1}
  local grpAct=${2}
  # Lines look like '0;s;0x00000010;0x00000019'
  local winIDs=$(grep "\^${grpID}" "${wmGrpLst}" | cut -d ';' -f 3+)

  if [[ "${winIDs}" == '' && "${grpAct}" != 'c' ]]; then
    echo "${grpID};s;" >> "${wmGrpLst}"
  fi

  case "${grpAct}" in
    's')
      sed -i "s/\^${grpID};h/${grpID};s/" "${wmGrpLst}"
      local newMod='s'
    ;;
    'h')
      sed -i "s/\^${grpID};s/${grpID};h/" "${wmGrpLst}"
      local newMod='h'
    ;;
    't')
      if [[ $(grep "\^${grpID};.*" "${wmGrpLst}" | cut -d ';' -f 2) == 's' ]]; then
        sed -i "s/\^${grpID};s/${grpID};h/" "${wmGrpLst}"
        local newMod='h'
      else
        sed -i "s/\^${grpID};h/${grpID};s/" "${wmGrpLst}"
        local newMod='s'
      fi
    ;;
    'c') sed -i "/^${grpID}/d" "${wmGrpLst}";;
  esac

  for winID in "${winIDs[@]}"; do
    case "${newMod}" in
      's') rstw "${winID}";;
      'h') modw h "${winID}";;
    esac
  done
}

# ch(ange) w(indow) l(ayout) t(ile)/f(loating)/m(onocycle)
function chwl(){
  return
}