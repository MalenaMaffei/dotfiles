#!/usr/bin/env bash

wmTMP='/tmp/.wm'
wmWinBkp="${wmTMP}/.wbkps"
wmGrpLst="${wmTMP}/.grpls"

# b(ac)k(u)p w(indow) <WID> [.. <WID>]
function bkpw(){
  for winID in "${@}"; do
    local winX=$(wattr x "${winID}")
    local winY=$(wattr y "${winID}")
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")
    echo "${winID};${winX};${winY};${winW};${winH}" | tee -a "${wmWinBkp}"
  done
}

# r(e)st(ore) w(indow) <WID> [.. <WID>]
function rstw(){
  for winID in "${@}"; do
    local winProp=$(grep "${winID}" "${wmWinBkp}")

    [[ "${winProp}" == '' ]] && continue

    local winX=$(echo "${winProp}" | cut -d ';' -f 2)
    local winY=$(echo "${winProp}" | cut -d ';' -f 3)
    local winW=$(echo "${winProp}" | cut -d ';' -f 4)
    local winH=$(echo "${winProp}" | cut -d ';' -f 5)

    wpt "${winX}" "${winY}" "${winW}" "${winH}" "${winID}"
  done
}

# foc(us) w(indow) l(eft)/r(ight)/u(p)/d(own)/p(rev)/n(ext)
function focw(){
  return
}

# mov(e) w(indow) l(eft)/r(ight)/u(p)/d(own) inc(+)/dec(-)/to(=) ?px/?% <WID> [.. <WID>]
function movw(){
  local moveDir=${1} # l|r|u|d
  local moveMod=${2} # +|-|=
  local moveVal=${3} # ?px|?%
  shift; shift; shift # clear above args
  local winIDs="${@}" # other args should be windows

  # if value is in percentage, calculate it now
  if [[ "${moveVal}" == *% ]]; then
    moveVal=$(echo "${moveVal}" | tr -d '%')
    local rootWin=$(lsw -r)
    local rootW=$(wattr w "${rootWin}")
    local rootH=$(wattr h "${rootWin}")
    if [[ "${moveDir}" == 'l' || "${moveDir}" == 'r' ]]; then
      moveVal=$(echo "scale=0; ${rootW}/100*${moveVal}" | bc -s)
    else
      moveVal=$(echo "scale=0; ${rootH}/100*${moveVal}" | bc -s)
    fi
  fi

  # if value has pixel suffix, remove it
  [[ "${moveVal}" == *px ]] && moveVal=$(echo "${moveVal}" | tr -d 'px')

  for winID in "${winIDs[@]}"; do
    local winX=$(wattr x "${winID}")
    local winY=$(wattr y "${winID}")

    if [[ "${moveDir}" == 'l' && "${moveMod}" == '+' ]] || [[ "${moveDir}" == 'r' && "${moveMod}" == '-' ]]; then
      winX=$((winX + moveVal))
    elif [[ "${moveDir}" == 'l' && "${moveMod}" == '-' ]] || [[ "${moveDir}" == 'r' && "${moveMod}" == '+' ]]; then
      winX=$((winX - moveVal))
    elif [[ "${moveDir}" == 'l' && "${moveMod}" == '=' ]]; then
      winX=$((moveVal))
    elif [[ "${moveDir}" == 'r' && "${moveMod}" == '=' ]]; then
      winX=$((rootW - moveVal))
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '+' ]] || [[ "${moveDir}" == 'd' && "${moveMod}" == '-' ]]; then
      winX=$((winY + moveVal))
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '-' ]] || [[ "${moveDir}" == 'd' && "${moveMod}" == '+' ]]; then
      winX=$((winY - moveVal))
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '=' ]]; then
      winY=$((moveVal))
    elif [[ "${moveDir}" == 'd' && "${moveMod}" == '=' ]]; then
      winY=$((rootH - moveVal))
    fi
    wmv "${winX}" "${winY}" "${winID}"
  done
}

# tel(eport) w(indow) <x> <y> <WID> [.. <WID>]
function telw(){
  local newX=${1}
  local newY=${2}
  shift; shift
  local winIDS="${@}"

  for winID in "${winIDs[@]}"; do
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    wpt "${winX}" "${winY}" "${winW}" "${winH}" "${winID}"
  done
}

# res(ize) w(indow) l(eft)/r(ight)/u(p)/d(own)/h(eight)/w(idth) inc(+)/dec(-)/to(=) ?px/?% <WID> [.. <WID>]
function resw(){
  local resDir=${1} # l|r|u|d
  local resMod=${2} # +|-|=
  local resVal=${3} # ?px|?%
  shift; shift; shift # clear above args
  local winIDs="${@}" # other args should be windows

  # if value is in percentage, calculate it now
  if [[ "${resVal}" == *% ]]; then
    resVal=$(echo "${resVal}" | tr -d '%')
    local rootWin=$(lsw -r)
    local rootW=$(wattr w "${rootWin}")
    local rootH=$(wattr h "${rootWin}")
    if [[ "${resDir}" == 'l' || "${resDir}" == 'r' || "${resDir}" == 'w' ]]; then
      resVal=$(echo "scale=0; ${rootW}/100*${resVal}" | bc -s)
    else
      resVal=$(echo "scale=0; ${rootH}/100*${resVal}" | bc -s)
    fi
  fi

  # if value has pixel suffix, reres it
  [[ "${resVal}" == *px ]] && resVal=$(echo "${resVal}" | tr -d 'px')

  for winID in "${winIDs[@]}"; do
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    if [[ "${resDir}" == 'l' && "${resMod}" == '+' ]] || [[ "${resDir}" == 'r' && "${resMod}" == '-' ]]; then
      winW=$((winW + resVal))
    elif [[ "${resDir}" == 'l' && "${resMod}" == '-' ]] || [[ "${resDir}" == 'r' && "${resMod}" == '+' ]]; then
      winW=$((winW - resVal))
    elif [[ "${resDir}" == 'w' && "${resMod}" == '=' ]]; then
      winW=$((resVal))
    elif [[ "${resDir}" == 'u' && "${resMod}" == '+' ]] || [[ "${resDir}" == 'd' && "${resMod}" == '-' ]]; then
      winH=$((winH + resVal))
    elif [[ "${resDir}" == 'u' && "${resMod}" == '-' ]] || [[ "${resDir}" == 'd' && "${resMod}" == '+' ]]; then
      winH=$((winH - resVal))
    elif [[ "${resDir}" == 'h' && "${resMod}" == '=' ]]; then
      winH=$((resVal))
    fi
    wrs -a "${winX}" "${winY}" "${winID}"
  done
}

# mod(ify) w(indow) (m)i(nimize)/(m)a(ximize)/r(estore) <WID> [.. <WID>]
function modw(){
  return
}

# mo(dify) w(indow) s(tacking order) inc(+)/dec(-)/to(=)/f(ront)/b(ack) ? <WID> [.. <WID>]
function mows(){
  return
}

# sna(p) w(indow) t(op)/b(ottom)/l(eft)/r(ight)/t(op)l(eft)/t(op)r(ight)/b(ottom)l(eft)/b(ottom)r(ight)/c(enter) <WID> [.. <WID>]
function snaw(){
  return
}

# b(ac)k(u)p g(roup) <GID> [.. <GID>]
function bkpg(){
  return
}

# r(e)st(ore) g(roup) <GID> [.. <GID>]
function rstg(){
  return
}

# gro(up) w(indow) <GID|all> add(+)/del(-)/set(=) <WID> [.. <WID>]
function grow(){
  return
}

# mod(ify) g(roup) <GID|all> s(how)/h(ide)/t(oggle)/c(lear)
function modg(){
  return
}

# ch(ange) w(indow) l(ayout) t(ile)/f(loating)/m(onocycle)
function chwl(){
  return
}