#!/usr/bin/env bash

wmTMP='/tmp/.wm'
wmWinBkp="${wmTMP}/.wbkps"
wmGrpLst="${wmTMP}/.grpls"
wmGrpBkp="${wmTMP}/.gbkps"
wmWinFS="${wmTMP}/.winfs"

# b(ac)k(u)p w(indow) <WID> [.. <WID>]
function bkpw(){
  for winID in "${@}"; do
    local winX=$(wattr x "${winID}")
    local winY=$(wattr y "${winID}")
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    [[ grep "${winID}" "${wmWinBkp}" ]] && continue

    echo "${winID};${winX};${winY};${winW};${winH}" | tee -a "${wmWinBkp}"
  done
}

# r(e)st(ore) w(indow) <WID> [.. <WID>]
function rstw(){
  for winID in "${@}"; do
    local winProp=$(grep "${winID}" "${wmWinBkp}")

    [[ "${winProp}" == '' ]] && continue

    local winX=$(echo "${winProp}" | cut -d ';' -f 2)
    local winY=$(echo "${winProp}" | cut -d ';' -f 3)
    local winW=$(echo "${winProp}" | cut -d ';' -f 4)
    local winH=$(echo "${winProp}" | cut -d ';' -f 5)

    wpt "${winX}" "${winY}" "${winW}" "${winH}" "${winID}" # Teleport window
    mapw -m # Show window

    sed -i "/${winID}/d" "${wmWinBkp}"
  done
}

# foc(us) w(indow) l(eft)/r(ight)/u(p)/d(own)/p(rev)/n(ext)
function focw(){
  case $1 in
    l) wtf $(lsw | xargs wattr xi | sort -nr | sed "0,/$CUR/d" | sed "1s/^[0-9]* //p;d");;
    r) wtf $(lsw | xargs wattr yi | sort -n | sed "0,/$CUR/d" | sed "1s/^[0-9]* //p;d");;
    u) wtf $(lsw | xargs wattr yi | sort -nr | sed "0,/$CUR/d" | sed "1s/^[0-9]* //p;d");;
    d) wtf $(lsw | xargs wattr xi | sort -n | sed "0,/$CUR/d" | sed "1s/^[0-9]* //p;d");;
    n) wtf $(lsw | grep -v $CUR | sed '1 p;d') ;;
    p) wtf $(lsw | grep -v $CUR | sed '$ p;d') ;;
  esac
}

# mov(e) w(indow) l(eft)/r(ight)/u(p)/d(own) inc(+)/dec(-)/to(=) ?px/?% <WID> [.. <WID>]
function movw(){
  local moveDir=${1} # l|r|u|d
  local moveMod=${2} # +|-|=
  local moveVal=${3} # ?px|?%
  shift; shift; shift # clear above args
  local winIDs="${@}" # other args should be windows

  # if value is in percentage, calculate it now
  if [[ "${moveVal}" == *% ]]; then
    moveVal=$(echo "${moveVal}" | tr -d '%')
    local rootWin=$(lsw -r)
    local rootW=$(wattr w "${rootWin}")
    local rootH=$(wattr h "${rootWin}")
    if [[ "${moveDir}" == 'l' || "${moveDir}" == 'r' ]]; then
      moveVal=$(echo "scale=0; ${rootW}/100*${moveVal}" | bc -s)
    else
      moveVal=$(echo "scale=0; ${rootH}/100*${moveVal}" | bc -s)
    fi
  fi

  # if value has pixel suffix, remove it
  [[ "${moveVal}" == *px ]] && moveVal=$(echo "${moveVal}" | tr -d 'px')

  for winID in "${winIDs[@]}"; do
    local winX=$(wattr x "${winID}")
    local winY=$(wattr y "${winID}")

    if [[ "${moveDir}" == 'l' && "${moveMod}" == '+' ]] || [[ "${moveDir}" == 'r' && "${moveMod}" == '-' ]]; then
      winX=$((winX + moveVal))
    elif [[ "${moveDir}" == 'l' && "${moveMod}" == '-' ]] || [[ "${moveDir}" == 'r' && "${moveMod}" == '+' ]]; then
      winX=$((winX - moveVal))
    elif [[ "${moveDir}" == 'l' && "${moveMod}" == '=' ]]; then
      winX=$((moveVal))
    elif [[ "${moveDir}" == 'r' && "${moveMod}" == '=' ]]; then
      winX=$((rootW - moveVal))
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '+' ]] || [[ "${moveDir}" == 'd' && "${moveMod}" == '-' ]]; then
      winX=$((winY + moveVal))
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '-' ]] || [[ "${moveDir}" == 'd' && "${moveMod}" == '+' ]]; then
      winX=$((winY - moveVal))
    elif [[ "${moveDir}" == 'u' && "${moveMod}" == '=' ]]; then
      winY=$((moveVal))
    elif [[ "${moveDir}" == 'd' && "${moveMod}" == '=' ]]; then
      winY=$((rootH - moveVal))
    fi
    wmv "${winX}" "${winY}" "${winID}"
  done
}

# tel(eport) w(indow) <x> <y> <WID> [.. <WID>]
function telw(){
  local newX=${1}
  local newY=${2}
  shift; shift
  local winIDS="${@}"

  for winID in "${winIDs[@]}"; do
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    wpt "${winX}" "${winY}" "${winW}" "${winH}" "${winID}"
  done
}

# res(ize) w(indow) l(eft)/r(ight)/u(p)/d(own)/h(eight)/w(idth) inc(+)/dec(-)/to(=) ?px/?% <WID> [.. <WID>]
function resw(){
  local resDir=${1} # l|r|u|d
  local resMod=${2} # +|-|=
  local resVal=${3} # ?px|?%
  shift; shift; shift # clear above args
  local winIDs="${@}" # other args should be windows

  # if value is in percentage, calculate it now
  if [[ "${resVal}" == *% ]]; then
    resVal=$(echo "${resVal}" | tr -d '%')
    local rootWin=$(lsw -r)
    local rootW=$(wattr w "${rootWin}")
    local rootH=$(wattr h "${rootWin}")
    if [[ "${resDir}" == 'l' || "${resDir}" == 'r' || "${resDir}" == 'w' ]]; then
      resVal=$(echo "scale=0; ${rootW}/100*${resVal}" | bc -s)
    else
      resVal=$(echo "scale=0; ${rootH}/100*${resVal}" | bc -s)
    fi
  fi

  # if value has pixel suffix, reres it
  [[ "${resVal}" == *px ]] && resVal=$(echo "${resVal}" | tr -d 'px')

  for winID in "${winIDs[@]}"; do
    local winW=$(wattr w "${winID}")
    local winH=$(wattr h "${winID}")

    if [[ "${resDir}" == 'l' && "${resMod}" == '+' ]] || [[ "${resDir}" == 'r' && "${resMod}" == '-' ]]; then
      winW=$((winW + resVal))
    elif [[ "${resDir}" == 'l' && "${resMod}" == '-' ]] || [[ "${resDir}" == 'r' && "${resMod}" == '+' ]]; then
      winW=$((winW - resVal))
    elif [[ "${resDir}" == 'w' && "${resMod}" == '=' ]]; then
      winW=$((resVal))
    elif [[ "${resDir}" == 'u' && "${resMod}" == '+' ]] || [[ "${resDir}" == 'd' && "${resMod}" == '-' ]]; then
      winH=$((winH + resVal))
    elif [[ "${resDir}" == 'u' && "${resMod}" == '-' ]] || [[ "${resDir}" == 'd' && "${resMod}" == '+' ]]; then
      winH=$((winH - resVal))
    elif [[ "${resDir}" == 'h' && "${resMod}" == '=' ]]; then
      winH=$((resVal))
    fi
    wrs -a "${winW}" "${winH}" "${winID}"
  done
}

# mod(ify) w(indow) (m)i(nimize)/(m)a(ximize)/d(efault) <WID> [.. <WID>]
function modw(){
  local winAct=${1}
  shift
  local winIDs="${@}"

  for winID in "${winIDs[@]}"; do
    case "${winAct}" in
      'i')
        bkpw "${winID}"
        mapw -u "${winID}"
      ;;
      'd')
        resw "${winID}"
      ;;
      'm')
        if [[ -f "${wmWinFS}" ]]; then
          resw $(cat "${wmWinFS}")
          rm "${wmWinFS}"
        fi
        bkpw "${winID}"
        mapw -m "${winID}"
        wtp $(wattr xywh `lsw -r`) "${winID}"
      ;;
    esac
  done

  return
}

# mo(dify) w(indow) s(tacking order) inc(+)/dec(-)/to(=)/f(ront)/b(ack) ? <WID> [.. <WID>]
function mows(){
  return
}

# sna(p) w(indow) t(op)/b(ottom)/l(eft)/r(ight)/t(op)l(eft)/t(op)r(ight)/b(ottom)l(eft)/b(ottom)r(ight)/c(enter) <WID> [.. <WID>]
function snaw(){
  local winPos=${1}
  shift
  local winIDs="${@}"

  local rootWin=$(lsw -r)
  local rootW=$(wattr w "${rootWin}")
  local rootH=$(wattr h "${rootWin}")

  for winID in "${winIDs[@]}"; do
    case "${winPos}" in
      't') wtp 0 0 "${rootW}" "$((rootH/2))" "${winID}";;
      'b') wtp 0 "$((rootH/2))" "${rootW}" "$((rootH/2))" "${winID}";;
      'l') wtp 0 0 "$((rootW/2))" "${rootH}" "${winID}";;
      'r') wtp "$((rootW/2))" 0 "$((rootW/2))" "${rootH}" "${winID}";;
      'tl') wtp 0 0 "$((rootW/2))" "$((rootH/2))" "${winID}";;
      'tr') wtp "$((rootW/2))" 0 "$((rootW/2))" "$((rootH/2))" "${winID}";;
      'bl') wtp 0 "$((rootW/2))" "$((rootW/2))" "$((rootH/2))" "${winID}";;
      'br') wtp "$((rootH/2))" "$((rootW/2))" "$((rootW/2))" "$((rootH/2))" "${winID}";;
      'c') wtp "$((rootW/4))" "$((rootH/4))" "$((rootW/2))" "$((rootH/2))" "${winID}";;
    esac
  done
}

# b(ac)k(u)p g(roup) <GID> [.. <GID>]
function bkpg(){
  return
}

# r(e)st(ore) g(roup) <GID> [.. <GID>]
function rstg(){
  return
}

# gro(up) w(indow) <GID|all> add(+)/del(-)/set(=) <WID> [.. <WID>]
function grow(){
  return
}

# mod(ify) g(roup) <GID|all> s(how)/h(ide)/t(oggle)/c(lear)
function modg(){
  return
}

# ch(ange) w(indow) l(ayout) t(ile)/f(loating)/m(onocycle)
function chwl(){
  return
}